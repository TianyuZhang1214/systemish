The PAUSE macro:

#define PAUSE(index) \
	asm("lea (%%rip), %%rax\n\t" "mov %%rax, %0" : "=r"(batch_rips[index]) :: "rax");

Stores the current instruction pointer into batch_rips[index].

Gotchas:
	1. As this is extended asm (arguments such as %0 are used), register names
	start with %%.
	
	2. We could do without the use of %%rax:

	-->	asm("lea (%%rip), %0" :: "=r"(batch_rips[index]) 

	"-->" denotes the instruction whose address we want to save, i.e., the value
	in the instruction pointer.

	This does not work as expected. To compute batch_rips[index], the instruction
	pointer gets advanced. So, the value that gets stored in batch_rips[index] is
	not what we want it to be.

	3. The rax register is "clobbered" after this gets executed.

The UNPAUSE macro:

#define UNPAUSE(index) \
	asm("mov %0, %%rax\n\t" "jmp *%%rax" :: "r" (batch_rips[index]) : "rax");
	
Jumps to the instruction stored in batch_rips[index]
